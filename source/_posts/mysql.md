---
layout: mysql
title: mysql
date: 2023-10-24 14:15:27
tags:
---

### mysql性能优化
#### 执行计划的含义
``` 
select_type

SIMPLE 简单的查询 不包含子查询 和 union
PRIMARY 如果查询有任何复杂的字部分，则最外层标记为PRIMARY
SUBQUERY 子查询中的SELECT（换句话说，不在FROM子句中的），标记为SUBQUERY
DERIVED  DERIVED 值用来表示包含在FROM字句的子查询中的SELECT
UNION 在union中的第二个和随后的SELECT被标记为union
UNION RESULT 用来从union的匿名临时表检索结果的SELECT被标记为UNION RESULT

table 列
这一列显示了对应行正在访问那个表 

type列

ALL 全表扫描

index 这个跟全表扫描类似，只是mysql是安装索引次序扫描而不是行，
主要优点是避免了排序，最大的缺点是承担了按索引读取整个表的开销，若是按随机次序访问行，开销将会非常大，
如果Extra列显示 Using Index 说明使用了覆盖索引，而不用回表，比按所以次序全表扫描开销要小很多

range 范围扫描就是一个有限制的索引扫描，它开始于索引里的某一点，返回匹配这个值域的行，
比全索引扫描要好一点，因为不用扫描全部索引

ref  这是一种索引访问，也叫索引查找，他返回所有匹配某个单个值的行，但是这个值可能有多个符合条件的行

ref_or_null 是ref的一个变体，它意味着mysql必须在初次查询的结果里，找出null条目

eq_req 使用索引查找，MySQL知道最多返回一条符合条件的记录

const,system 当MySQL能对查询的某部分进行优化并将其转换成一个常量时，他会使用这些访问类型

null 这个访问方式意味着MySQL能在优化阶段分解查询语句，在执行阶段甚至用不着再访问表或者索引

possible_keys 列

这一列显示查询可以使用哪些索引

key 列

这一列显示了MySQL决定采用哪个索引来优化对该表的访问

ket_len列

这列显示了MySQL在索引里使用的字节数

ref 列

这一列显示的是之前的表在key列记录的索引中实际所用的列或常量

rows 列

这一列是MySQL估计为了找到所需的行而要读取的行数

filtered列

它显示的是针对表里符合某个条件的记录数的百分比所做的一个悲观估算

Extra列

Using index 
此值表示MySQL将使用覆盖索引，以避免访问表，不要把覆盖索引和索引访问类型弄混了

Using where
这意味着MySQL服务器将在存储引擎检索行后再进行过滤

Using temporary
这意味着MySQL在对查询结果排序时会使用一个临时表

Using filesort
这意味着MySQL会对结果使用一个外部索引排序，而不是按索引次序从表里读取行，
MySQL有两种文件排序算法，两种方式都可以在内存或磁盘上完成，执行计划不会告诉你MySQL是使用的哪一种文件排序，
也不会告诉你排序时在内存还是在磁盘完成的

Range checked for each record(index map:N)
这意味着没有好用的索引，新的索引将在连接的每一行上重新估算
```

#### 高性能的索引策略
```
何为三星索引
1.索引将相关的记录放到一起获得一星
2.索引中的数据顺序和查找中的排列顺序一致获得二星
3.索引中包含了需要的全部列获得三星


独立的列

索引列不能是表达式的一部分 或者函数参数，否则无法使用索引

select * from tbl where key1 + 1 = 5  无法使用索引列key1


前缀索引和索引选择性

对于比较长的列 比如 TEXT 或者很长的 varchar列  需要决定合适长度的索引前缀且保证索引的选择性要高


多列索引
多列索引并不是为每个列创建单独的索引，也不能按照错误的顺序创建多列索引

选择合适的索引列顺序
如何选择索引的列顺序有一个经验法则：将选择性最高的列放到索引最前列

聚簇索引
1.索引中保存了索引记录和数据行的完整信息
2.在innodb表中按主键顺序插入行
最好避免随机的聚簇索引，例如从性能的角度考虑，使用UUID作为聚簇索引会非常糟糕，他使得聚簇索引的插入变的完全随机，
这是最坏的情况，🙆🏻使得数据没有任何聚集特性
3.顺序的主键什么时候会造成更坏的结果：高并发的场景，会出现明显的主键争用

覆盖索引
如果一个索引包含所有需要查询的字段值，就称为覆盖索引

覆盖索引带来的好处
1.只需要扫描索引，而无需回表
2.索引条目通常远小于数据行的大小，可以极大的减少数据访问量，这对缓存的负载非常重要
3.因为索引是按照列值顺序存储的（至少单个页内是如此），所以对于IO密集型的范围查询会比随机从磁盘读取每一行数据的IO要少得多
4.二级索引能够覆盖查询，可以避免对主键索引的二次查询

不是所有的类型的索引都可以成为覆盖索引，覆盖索引必须要存储索引列的值，而哈希索引，空间索引，全文索引不存储列值，
所以不能成为覆盖索引，只能使用btree索引做覆盖索引

当发起一个被索引覆盖的查询时，Extra列可以看到 Using index
```